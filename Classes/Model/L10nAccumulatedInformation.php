<?php
namespace Localizationteam\L10nmgr\Model;

/***************************************************************
 *  Copyright notice
 *  (c) 2006 Kasper Skårhøj <kasperYYYY@typo3.com>
 *  All rights reserved
 *  This script is part of the TYPO3 project. The TYPO3 project is
 *  free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *  The GNU General Public License can be found at
 *  http://www.gnu.org/copyleft/gpl.html.
 *  This script is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  This copyright notice MUST APPEAR in all copies of the script!
 ***************************************************************/

use Localizationteam\L10nmgr\Model\Tools\InlineRelationTool;
use Localizationteam\L10nmgr\Model\Tools\Tools;
use TYPO3\CMS\Backend\Utility\BackendUtility;
use TYPO3\CMS\Core\Database\ReferenceIndex;
use TYPO3\CMS\Core\Utility\GeneralUtility;

/**
 * l10nAccumulatedInformations
 *  calculates accumulated informations for a l10n.
 *    Needs a tree object and a l10ncfg to work.
 *  This object is a value object (means it has no identity and can therefore be created and deleted “everywhere”).
 *  However this object should be generated by the relevant factory method in the l10nconfiguration object.
 * This object represents the relevant records which belongs to a l10ncfg in the concrete pagetree!
 *  The main method is the getInfoArrayForLanguage() which returns the $accum Array with the accumulated informations.
 *
 * @package TYPO3
 * @subpackage tx_l10nmgr
 */
class L10nAccumulatedInformation
{
    protected $excludeIndex;
    protected $tableUidContraintIndex;
    /**
     * @var array
     */
    protected $flexFormDiff;

    /**
     * @var string The status of this object, set to processed if internal variables are calculated.
     */
    var $objectStatus = 'new';
    
    /**
     * @var array Page tree
     */
    var $tree = array();
    
    /**
     * @var array Selected l10nmgr configuration
     */
    var $l10ncfg = array();
    
    /**
     * @var array List of not allowed doktypes
     */
    var $disallowDoktypes = array('--div--', '255');
    
    /**
     * @var int sys_language_uid of source language
     */
    var $sysLang;
    
    /**
     * @var int sys_language_uid of target language
     */
    var $forcedPreviewLanguage;
    
    /**
     * @var array Information about collected data for translation
     */
    var $_accumulatedInformation = array();
    
    /**
     * @var int Field count, might be needed by tranlation agencies
     */
    var $_fieldCount = 0;
    
    /**
     * @var int Word count, might be needed by tranlation agencies
     */
    var $_wordCount = 0;
    
    /**
     * @var array Extension's configuration as from the EM
     */
    protected $extensionConfiguration = array();

    /**
     * @var Tools
     */
    protected $t8Tools;



    /**
     * @var ReferenceIndex
     */
    protected $referenceIndex = NULL;

    /**
	 * Constructor
	 *
	 * @param $tree
	 * @param $l10ncfg
	 * @param $sysLang
	 *
	 */
    function __construct($tree, $l10ncfg, $sysLang)
    {
        // Load the extension's configuration
        $this->extensionConfiguration = unserialize($GLOBALS['TYPO3_CONF_VARS']['EXT']['extConf']['l10nmgr']);
        $this->disallowDoktypes = GeneralUtility::trimExplode(',', $this->extensionConfiguration['disallowDoktypes']);

        $this->referenceIndex = GeneralUtility::makeInstance(ReferenceIndex::class);

        $this->tree = $tree;
        $this->l10ncfg = $l10ncfg;
        $this->sysLang = $sysLang;
    }

    function setForcedPreviewLanguage($prevLangId)
    {
        $this->forcedPreviewLanguage = $prevLangId;
    }

    /**
     * return information array with accumulated information. This way client classes have access to the accumulated array directly. and can read this array in order to create some output...
     *
     * @return  array    Complete Information array
     */
    function getInfoArray()
    {
        $this->process();

        return $this->_accumulatedInformation;
    }

    function process()
    {
        if ($this->objectStatus != 'processed') {
            $this->_calculateInternalAccumulatedInformationsArray();
        }
        $this->objectStatus = 'processed';
    }

    /** set internal _accumulatedInformation array. Is called from constructor and uses the given tree, lang and l10ncfg
     *
     * @return void
     **/
    function _calculateInternalAccumulatedInformationsArray()
    {
        global $TCA;
        $tree = $this->tree;
        $l10ncfg = $this->l10ncfg;
        $this->_accumulatedInformation = array();

        // FlexForm Diff data:
        $this->flexFormDiff = unserialize($l10ncfg['flexformdiff']);
        $this->flexFormDiff = $this->flexFormDiff[$this->sysLang];

        $this->excludeIndex = array_flip(GeneralUtility::trimExplode(',', $l10ncfg['exclude'], 1));
        $this->tableUidContraintIndex = array_flip(GeneralUtility::trimExplode(',', $l10ncfg['tableUidConstraint'], 1));

        // Init:
        $this->t8Tools = GeneralUtility::makeInstance(Tools::class);
        $this->t8Tools->verbose = false; // Otherwise it will show records which has fields but none editable.
        if ($l10ncfg['incfcewithdefaultlanguage'] == 1) {
            $this->t8Tools->includeFceWithDefaultLanguage = true;
        }

        // Set preview language (only first one in list is supported):
        if ($this->forcedPreviewLanguage != '') {
            $previewLanguage = $this->forcedPreviewLanguage;
        } else {
            $previewLanguage = current(GeneralUtility::intExplode(',',
                $GLOBALS['BE_USER']->getTSConfigVal('options.additionalPreviewLanguages')));
        }
        if ($previewLanguage) {
            $this->t8Tools->previewLanguages = array($previewLanguage);
        }

        // Traverse tree elements:
        foreach ($tree->tree as $treeElement) {

            $pageId = $treeElement['row']['uid'];
            if (
                // check if page is allowed in export
                !isset($this->excludeIndex['pages:' . $pageId])
                && !in_array($treeElement['row']['doktype'], $this->disallowDoktypes)
            ) {
                $this->_accumulatedInformation[$pageId]['header']['title'] = $treeElement['row']['title'];
                $this->_accumulatedInformation[$pageId]['header']['icon'] = $treeElement['HTML'];
                $this->_accumulatedInformation[$pageId]['header']['prevLang'] = $previewLanguage;
                $this->_accumulatedInformation[$pageId]['items'] = array();

                // Traverse tables:
                foreach ($TCA as $table => $cfg) {

                    // Only those tables we want to work on:
                    if (GeneralUtility::inList($l10ncfg['tablelist'], $table)) {

                        if ($table === 'pages') {
                            $row = BackendUtility::getRecordWSOL('pages', $pageId);
                            $this->addRow($pageId, 'pages', $row);
                        } else {
                            $allRows = $this->t8Tools->getRecordsToTranslateFromTable($table, $pageId);

                            if (is_array($allRows) && count($allRows) > 0) {
                                // Now, for each record, look for localization:
                                foreach ($allRows as $row) {
                                    if(! $this->rowIsExcluded($table, $row)) {
                                        BackendUtility::workspaceOL($table, $row);
                                        $this->addRow($pageId, $table, $row);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        $includeIndex = array_unique(GeneralUtility::trimExplode(',', $l10ncfg['include'], 1));
        foreach ($includeIndex as $recId) {
            list($table, $uid) = explode(':', $recId);
            $row = BackendUtility::getRecordWSOL($table, $uid);
            if (count($row)) {
                $this->addRow(-1, $table, $row);
            }
        }


        $this->addRelatedRecords();

        if($this->l10ncfg['nest_inline_records']) {
            $flattened = $this->flattenAccumulatedRecords();

            /** @var InlineRelationTool $inlineRelationTool */
            $inlineRelationTool = GeneralUtility::makeInstance(InlineRelationTool::class, $this->l10ncfg);
            $inlineRelationTool->addNestingInformation($flattened);
        }
    }

    /**
     * @param $accum
     * @return array $table => $uid => $row
     */
    public function flattenAccumulatedRecords()
    {
        $flattened = [];
        foreach ($this->_accumulatedInformation as &$pages) {
            foreach ($pages['items'] as $table => &$records) {
                foreach ($records as $uid => &$record) {
                    if (!array_key_exists($table, $flattened)) {
                        $flattened[$table] = [];
                    }
                    $flattened[$table][$uid] = &$record;
                }
            }
        }

        return $flattened;
    }

    function _increaseInternalCounters($fieldsArray)
    {
        if (is_array($fieldsArray)) {
            $this->_fieldCount = $this->_fieldCount + count($fieldsArray);
            if (function_exists('str_word_count')) {
                foreach ($fieldsArray as $v) {
                    $this->_wordCount = $this->_wordCount + str_word_count($v['defaultValue']);
                }
            }
        }
    }

    function getFieldCount()
    {
        return $this->_fieldCount;
    }

    function getWordCount()
    {
        return $this->_wordCount;
    }

    private function addRow($pageId, $table, $row)
    {
        $uid = $row['uid'];

        $translationDetails = $this->t8Tools->translationDetails(
            $table,
            $row,
            $this->sysLang,
            $this->flexFormDiff
        );

        if(! is_null($translationDetails)) {
            // create dummy page if needed
            if(! array_key_exists($pageId, $this->_accumulatedInformation)) {
                $this->_accumulatedInformation[$pageId] = [
                    'header' => [
                        'title' => 'Record Collection',
                    ],
                    'items' => [],
                ];
            }

            $this->_accumulatedInformation[$pageId]['items'][$table][$uid] = $translationDetails;
            $this->_increaseInternalCounters($translationDetails['fields']);
        }
    }

    /**
     * @param $table
     * @param $row
     * @return array
     */
    protected function rowIsExcluded($table, $row)
    {
        $rowSignature = $table . ':' . $row['uid'];

        $rowShallBeIncluded =
            is_array($row)
            && (
                // if there is a table uid constraint, our row needs to be in it
                !is_array($this->tableUidContraintIndex)
                || count($this->tableUidContraintIndex) == 0
                || array_key_exists(
                    $rowSignature,
                    $this->tableUidContraintIndex
                )
            )
            && (
                // row should not be explicetly excluded
                !isset($this->excludeIndex[$rowSignature])
            )
        ;

        return ! $rowShallBeIncluded;
    }


    /**
     * @return array
     */
    protected function addRelatedRecords()
    {
        $flattened = $this->flattenAccumulatedRecords();

        $recordsToCheckRelations = [];
        $alreadyKnown = [];
        foreach ($flattened as $table => $records) {
            foreach ($records as $uid => $record) {
                $recordSignature = new RecordSignature($table, $uid);
                $recordsToCheckRelations[] = $recordSignature;
                $alreadyKnown[$recordSignature->toString()] = TRUE;
            }
        }

        $allPagesInTree = [$this->l10ncfg['pid']];
        foreach($this->tree->ids as $id) {
            $allPagesInTree[] = $id;
        }

        /** @var RecordSignature $parentRecordSignature */
        while ($parentRecordSignature = array_pop($recordsToCheckRelations)) {
            $parentRow = BackendUtility::getRecordWSOL($parentRecordSignature->table, $parentRecordSignature->uid);
            $relations = $this->referenceIndex->getRelations($parentRecordSignature->table, $parentRow);

            foreach ($relations as $relation) {
                if ($relation['type'] == 'db') {
                    foreach ($relation['itemArray'] as $relatedRecord) {
                        $table = $relatedRecord['table'];
                        $uid = $relatedRecord['id'];
                        $childRecordSignature = new RecordSignature($table, $uid);

                        if(!(isset($alreadyKnown[$childRecordSignature->toString()]))) {

                            $childRow = BackendUtility::getRecordWSOL($table, $uid);
                            if (is_array($childRow)) {
                                $positionInTree = array_key_exists('pid', $childRow) ? $childRow['pid'] : 0;

                                $rowShallBeIncluded =
                                    ! $this->rowIsExcluded($table, $childRow)
                                    && (
                                        $positionInTree == 0
                                        || in_array($positionInTree, $allPagesInTree)
                                    )
                                ;

                                if ($rowShallBeIncluded) {
                                    $this->addRow($childRow['pid'], $table, $childRow);
                                    $alreadyKnown[$childRecordSignature->toString()] = TRUE;
                                    $recordsToCheckRelations[] = $childRecordSignature;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}